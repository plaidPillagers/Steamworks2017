// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc2538.Steamworks.subsystems;


import org.usfirst.frc2538.Steamworks.Robot;
import org.usfirst.frc2538.Steamworks.RobotMap;
import org.usfirst.frc2538.Steamworks.commands.*;

import com.ctre.CANTalon;
import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.Victor;
import edu.wpi.first.wpilibj.smartdashboard.*;
import edu.wpi.first.wpilibj.command.Subsystem;


/**
 *
 */
public class Shooter extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final Encoder rotationEncoder = RobotMap.shooterRotationEncoder;
    private final SpeedController shooterRotation = RobotMap.shooterShooterRotation;
    private final PIDController rotation = RobotMap.shooterRotation;
    private final SpeedController engageShooter = RobotMap.shooterEngageShooter;
    private final SpeedController wheelMotor = RobotMap.shooterWheelMotor;
    private final Encoder wheelEncoder = RobotMap.shooterWheelEncoder;
    private final PIDController shooter = RobotMap.shooterShooter;
    private final DigitalInput roationHighStop = RobotMap.shooterroationHighStop;
    private final DigitalInput roataionLowStop = RobotMap.shooterroataionLowStop;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
public boolean active= false;
public boolean encoderInitialized = false;

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new EncoderSetup());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }
    
   
     public void enablePID(int target){
    	 Joystick j=Robot.oi.secondaryJoystick;
    	 SmartDashboard.putString("PID Command", "Setting PID");
    	 int newTarget=(int) (5000*j.getZ());
    	 int currentPosition=rotationEncoder.get();
    	 if(Math.abs(newTarget-currentPosition)<500)
    	 	return;
    	 SmartDashboard.putString("PID Target", Integer.toString(newTarget));
    	 if (!isHighStop() && !isLowStop()){
    		 rotation.setSetpoint(newTarget);
    		 rotation.enable();
    	 }
     }
     
     public void disablePID(){
    	 rotation.disable();
     }
     public boolean done(){
    	 int targetValue=(int)rotation.getSetpoint();
    	 int enc=rotationEncoder.get();
    	 String os=Integer.toString(enc);
    	 SmartDashboard.putString("PID Value",os);
    	 if(rotation.onTarget() || Math.abs(targetValue-enc)<500 ||isHighStop()||isLowStop()){
    		 os="Reached" + Integer.toString(enc);
    		 SmartDashboard.putString("PID Command", os);
    		 return true;
    	 }
    	 return false;
     }
   


     public boolean isHighStop(){
    	 return roationHighStop.get();
    	 //return false;
	}
     
     
    public boolean isLowStop(){
//    	return g;
    	return roataionLowStop.get();
     }
    
    public boolean activateEscaloader(){
    	engageShooter.set(1.0);
    	return false;
    }
    public boolean activateShooter(){
    	active = !active;
    	if (active){
    		double speed =Robot.oi.secondaryJoystick.getThrottle();
    		speed=-0.5*speed+0.5;
    		SmartDashboard.putString("ultraDistance",Double.toString(speed));
    	//wheelMotor.set(1.0);
    	}
    	return true;
    }
    public void angleShooting(){
    	double speed = Robot.oi.secondaryJoystick.getY();
    	if ((speed>0&&!isHighStop())||(speed<0&&!isLowStop())){
        	shooterRotation.set(speed);
    	}
    	else{
    		shooterRotation.set(0.0);
    	}
    	int location = rotationEncoder.get();
    	SmartDashboard.putString("Shooter position",Integer.toString(location));
    }

    public boolean defaultShooter(){
    	boolean g=roataionLowStop.get();
    	SmartDashboard.putString("Limit Switch", ""+g);
    	if (!encoderInitialized){
    		if(isLowStop()){
    			rotationEncoder.reset();
    			encoderInitialized=true;
    			shooterRotation.set(0.0);
    		}else{
    			shooterRotation.set(-.7);
    		}
    	}
    	return encoderInitialized;
    }
}



